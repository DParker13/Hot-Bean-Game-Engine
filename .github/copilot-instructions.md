# Hot Bean Engine – AI Guide
- **Architecture**: ECS in Austin Morlan style. Core managers live under [HotBeanEngine/include/HotBeanEngine/application/managers](HotBeanEngine/include/HotBeanEngine/application/managers) and are wired together by the singleton `Application` ([HotBeanEngine/include/HotBeanEngine/application/application.hpp](HotBeanEngine/include/HotBeanEngine/application/application.hpp)). `ComponentManager` stores sparse-set component data and keeps `ComponentID ↔ name` maps; `EntityManager` owns signatures and ID recycling; `SystemManager` tracks registered systems, signatures, and dispatch across game-loop states.
- **Game loop**: `Application::Start()` runs SDL event polling, fixed-step physics (`GameLoopState::OnFixedUpdate`), and render phases ([HotBeanEngine/src/application/application.cpp](HotBeanEngine/src/application/application.cpp)). State control is centralized in `GameLoopManager` (play/pause/stop with reload flagging) and exposed via `Application::PlayGame/PauseGame/StopGame`.
- **Globals and macros**: `g_app`/`g_ecs` (from [HotBeanEngine/include/HotBeanEngine/application/macros.hpp](HotBeanEngine/include/HotBeanEngine/application/macros.hpp)) give singleton access; `DEFINE_SIGNATURE` and `EXTEND_SYSTEM` stamp a system’s name and required components; LOG macros ultimately route to `LoggingManager` (default level from config).
- **Component conventions**: Components inherit `IComponent` (+ optional `IMemberChanged` and editor `IPropertyRenderable`). They must provide `StaticGetName()` (use `DEFINE_NAME`) and typically implement `Serialize/Deserialize` for YAML ([defaults example Transform2D](HotBeanEngine/include/HotBeanEngine/defaults/components/miscellaneous/transform_2d.hpp)). Component registration is explicit—add new types to `DefaultComponentFactory::RegisterComponents` and extend `CreateComponentFromYAML` for deserialization ([HotBeanEngine/src/defaults/default_component_factory.cpp](HotBeanEngine/src/defaults/default_component_factory.cpp)). ECS limits: `MAX_ENTITIES=50000`, `MAX_COMPONENTS=64` ([HotBeanEngine/include/HotBeanEngine/core/config.hpp](HotBeanEngine/include/HotBeanEngine/core/config.hpp)).
- **System conventions**: Systems inherit `ISystem` (lifecycle hooks: OnStart/OnPreEvent/OnEvent/OnWindowResize/OnFixedUpdate/OnUpdate/OnRender/OnPostRender; see [HotBeanEngine/include/HotBeanEngine/core/isystem.hpp](HotBeanEngine/include/HotBeanEngine/core/isystem.hpp)). Register via `g_ecs.RegisterSystem`; signatures must be set (usually inside `SetSignature()` using `DEFINE_SIGNATURE`). `SystemManager` enforces signature-based entity membership and ordering ([HotBeanEngine/include/HotBeanEngine/application/managers/system_manager.hpp](HotBeanEngine/include/HotBeanEngine/application/managers/system_manager.hpp)).
- **Defaults package**: `HotBeanEngine_Defaults.hpp` pulls core + default components/systems ([HotBeanEngine/include/HotBeanEngine/HotBeanEngine_Defaults.hpp](HotBeanEngine/include/HotBeanEngine/HotBeanEngine_Defaults.hpp)). Default systems (input, audio, physics via Box2D, transform/camera, rendering, UI) are registered in order inside `DefaultScene::SetupSystems()` ([HotBeanEngine/src/defaults/default_scene.cpp](HotBeanEngine/src/defaults/default_scene.cpp)). They use macros for signatures (e.g., TransformSystem, PhysicsSystem, RenderSystem).
- **Scenes**: Scenes derive from `HBE::Core::Scene`; default implementation `DefaultScene` loads systems and is serializable to YAML via `DefaultSceneSerializer` ([HotBeanEngine/include/HotBeanEngine/defaults/default_scene.hpp](HotBeanEngine/include/HotBeanEngine/defaults/default_scene.hpp), [HotBeanEngine/src/defaults/default_scene_serializer.cpp](HotBeanEngine/src/defaults/default_scene_serializer.cpp)). Serialization walks components and nested entities; deserialization relies on the component factory. Parent-child transforms are tracked via `Transform2D::m_parent` and scene graph utilities.
- **Example game usage**: `Game::ExampleGame` extends `Application`, constructs a `DefaultSceneSerializer`, registers/loads `ExampleScene` ([Game/src/game/example_game.cpp](Game/src/game/example_game.cpp)). `ExampleScene` builds entities with default components and can extend default systems (e.g., custom audio system using `EXTEND_SYSTEM`) ([Game/src/scenes/example_scene.cpp](Game/src/scenes/example_scene.cpp), [Game/src/systems/audio_system.cpp](Game/src/systems/audio_system.cpp)). YAML scenes live under `Game/src/scenes/*.yaml` and are copied to the build output.
- **Config and assets**: `config.yaml` (one per game; copied to build dir) is loaded on `Application` startup to override window/logging defaults ([HotBeanEngine/include/HotBeanEngine/core/config.hpp](HotBeanEngine/include/HotBeanEngine/core/config.hpp)). Assets under `Game/assets` are post-build copied alongside scenes ([Game/CMakeLists.txt](Game/CMakeLists.txt)).
- **Build workflow (Linux)**: from repo root, `cmake -S . -B build` then `cmake --build build`. Executable ends up at `build/Game/Game`. Dependencies are fetched via CMake `FetchContent` (SDL3, SDL3_* extras, Box2D, yaml-cpp, glm, ImGui). Use the provided VS Code task “Format All C++ Files” for clang-formatting; “Generate Doxygen Documentation” builds docs in `HotBeanEngine/docs`.
- **Running**: from the build dir run `./Game/Game` (ensure `config.yaml`, `assets/`, and `scenes/` were copied by CMake). SDL3 needs a working audio device; errors surface via `LoggingManager` and SDL message boxes.
- **Tests**: unit tests live in `HotBeanEngine/src/unit_tests`; CMake target `HotBeanEngine_Managers_Test` (Catch2). After configuring, run `ctest --output-on-failure` in `build`.
- **Common extension points**: add components under `HotBeanEngine/include/HotBeanEngine/defaults/components/...`, systems under `.../defaults/systems/...`, update factory/serializer when introducing new component types, and register systems in your scene’s `SetupSystems()`.